{
  "tools_development": {
    "time_processor": "```python\n# tools/generated_tools/time_processor.py\n\nimport datetime\nimport pytz\nfrom typing import Optional, Dict, Tuple\n\nclass TimeProcessor:\n    \"\"\"\n    时间处理工具，用于处理时间相关的操作，如获取当前时间、判断时间段等\n    \"\"\"\n    \n    # 定义时间段常量\n    MORNING = \"morning\"      # 早晨 06:00-12:00\n    AFTERNOON = \"afternoon\"  # 下午 12:00-18:00\n    EVENING = \"evening\"      # 晚上 18:00-22:00\n    NIGHT = \"night\"          # 深夜 22:00-06:00\n    \n    # 定义时间段边界（小时）\n    TIME_RANGES = {\n        MORNING: (6, 12),    # 早晨: 6点到12点\n        AFTERNOON: (12, 18), # 下午: 12点到18点\n        EVENING: (18, 22),   # 晚上: 18点到22点\n        NIGHT: (22, 6)       # 深夜: 22点到6点\n    }\n    \n    @staticmethod\n    def get_current_time(timezone: Optional[str] = None) -> datetime.datetime:\n        \"\"\"\n        获取当前时间，可指定时区\n        \n        Args:\n            timezone: 时区字符串，如 'Asia/Shanghai'，'UTC'，默认为系统时区\n            \n        Returns:\n            datetime.datetime: 当前时间对象\n            \n        Raises:\n            ValueError: 时区格式不正确\n        \"\"\"\n        try:\n            if timezone:\n                tz = pytz.timezone(timezone)\n                return datetime.datetime.now(tz)\n            else:\n                return datetime.datetime.now()\n        except pytz.exceptions.UnknownTimeZoneError as e:\n            raise ValueError(f\"Invalid timezone: {timezone}\") from e\n    \n    @staticmethod\n    def get_greeting_type(dt: datetime.datetime) -> str:\n        \"\"\"\n        根据时间确定问候类型\n        \n        Args:\n            dt: 时间对象\n            \n        Returns:\n            str: 问候类型 (morning, afternoon, evening, night)\n        \"\"\"\n        hour = dt.hour\n        \n        if 6 <= hour < 12:\n            return TimeProcessor.MORNING\n        elif 12 <= hour < 18:\n            return TimeProcessor.AFTERNOON\n        elif 18 <= hour < 22:\n            return TimeProcessor.EVENING\n        else:  # 22-24, 0-6\n            return TimeProcessor.NIGHT\n    \n    @staticmethod\n    def format_timestamp(dt: datetime.datetime) -> str:\n        \"\"\"\n        将时间格式化为ISO 8601格式\n        \n        Args:\n            dt: 时间对象\n            \n        Returns:\n            str: 格式化的时间字符串\n        \"\"\"\n        return dt.isoformat()\n    \n    @staticmethod\n    def format_uptime(seconds: float) -> str:\n        \"\"\"\n        将运行时间（秒）格式化为可读字符串\n        \n        Args:\n            seconds: 运行秒数\n            \n        Returns:\n            str: 格式化的运行时间，如 \"2h 15m 30s\"\n        \"\"\"\n        hours, remainder = divmod(int(seconds), 3600)\n        minutes, seconds = divmod(remainder, 60)\n        return f\"{hours}h {minutes}m {seconds}s\"\n    \n    @staticmethod\n    def validate_timezone(timezone: str) -> bool:\n        \"\"\"\n        验证时区字符串是否有效\n        \n        Args:\n            timezone: 要验证的时区字符串\n            \n        Returns:\n            bool: 是否为有效时区\n        \"\"\"\n        try:\n            pytz.timezone(timezone)\n            return True\n        except pytz.exceptions.UnknownTimeZoneError:\n            return False\n```",
    
    "greeting_generator": "```python\n# tools/generated_tools/greeting_generator.py\n\nfrom typing import Dict, Optional\nfrom .time_processor import TimeProcessor\n\nclass GreetingGenerator:\n    \"\"\"\n    问候语生成工具，根据时间类型、用户名和语言生成合适的问候语\n    \"\"\"\n    \n    # 中文问候模板\n    ZH_TEMPLATES = {\n        TimeProcessor.MORNING: {\n            \"generic\": \"早上好！\",\n            \"personalized\": \"早上好，{name}！\"\n        },\n        TimeProcessor.AFTERNOON: {\n            \"generic\": \"下午好！\",\n            \"personalized\": \"下午好，{name}！\"\n        },\n        TimeProcessor.EVENING: {\n            \"generic\": \"晚上好！\",\n            \"personalized\": \"晚上好，{name}！\"\n        },\n        TimeProcessor.NIGHT: {\n            \"generic\": \"您好！\",\n            \"personalized\": \"您好，{name}！\"\n        }\n    }\n    \n    # 英文问候模板\n    EN_TEMPLATES = {\n        TimeProcessor.MORNING: {\n            \"generic\": \"Good morning!\",\n            \"personalized\": \"Good morning, {name}!\"\n        },\n        TimeProcessor.AFTERNOON: {\n            \"generic\": \"Good afternoon!\",\n            \"personalized\": \"Good afternoon, {name}!\"\n        },\n        TimeProcessor.EVENING: {\n            \"generic\": \"Good evening!\",\n            \"personalized\": \"Good evening, {name}!\"\n        },\n        TimeProcessor.NIGHT: {\n            \"generic\": \"Hello!\",\n            \"personalized\": \"Hello, {name}!\"\n        }\n    }\n    \n    # 支持的语言映射表\n    LANGUAGE_TEMPLATES = {\n        \"zh\": ZH_TEMPLATES,\n        \"en\": EN_TEMPLATES\n    }\n    \n    # 支持的语言列表\n    SUPPORTED_LANGUAGES = list(LANGUAGE_TEMPLATES.keys())\n    \n    @staticmethod\n    def generate_greeting(greeting_type: str, name: Optional[str] = None, language: str = \"zh\") -> str:\n        \"\"\"\n        生成问候语\n        \n        Args:\n            greeting_type: 问候类型 (morning, afternoon, evening, night)\n            name: 用户名称，如不提供则使用通用问候\n            language: 语言代码，支持 'zh'(中文) 和 'en'(英文)，默认为中文\n            \n        Returns:\n            str: 生成的问候语\n            \n        Raises:\n            ValueError: 不支持的语言或问候类型\n        \"\"\"\n        # 验证语言\n        if language not in GreetingGenerator.SUPPORTED_LANGUAGES:\n            raise ValueError(f\"Unsupported language: {language}\")\n        \n        # 获取对应语言的模板\n        templates = GreetingGenerator.LANGUAGE_TEMPLATES[language]\n        \n        # 验证问候类型\n        if greeting_type not in templates:\n            raise ValueError(f\"Invalid greeting type: {greeting_type}\")\n        \n        # 选择合适的模板\n        template_set = templates[greeting_type]\n        if name and name.strip():\n            template = template_set[\"personalized\"]\n            return template.format(name=name)\n        else:\n            return template_set[\"generic\"]\n    \n    @staticmethod\n    def is_language_supported(language: str) -> bool:\n        \"\"\"\n        检查语言是否支持\n        \n        Args:\n            language: 语言代码\n            \n        Returns:\n            bool: 是否支持该语言\n        \"\"\"\n        return language in GreetingGenerator.SUPPORTED_LANGUAGES\n```",
    
    "input_validator": "```python\n# tools/generated_tools/input_validator.py\n\nfrom typing import Dict, Any, Optional, List, Tuple\nfrom .time_processor import TimeProcessor\nfrom .greeting_generator import GreetingGenerator\n\nclass InputValidator:\n    \"\"\"\n    输入验证工具，用于验证API请求参数\n    \"\"\"\n    \n    # 验证规则常量\n    MAX_NAME_LENGTH = 50\n    MIN_NAME_LENGTH = 1\n    \n    @staticmethod\n    def validate_name(name: str) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        验证用户名称\n        \n        Args:\n            name: 用户名称\n            \n        Returns:\n            Tuple[bool, Optional[str]]: (是否有效, 错误信息)\n        \"\"\"\n        if not name or not isinstance(name, str):\n            return False, \"Name is required\"\n        \n        if len(name) < InputValidator.MIN_NAME_LENGTH:\n            return False, f\"Name must be at least {InputValidator.MIN_NAME_LENGTH} character\"\n        \n        if len(name) > InputValidator.MAX_NAME_LENGTH:\n            return False, f\"Name cannot exceed {InputValidator.MAX_NAME_LENGTH} characters\"\n        \n        return True, None\n    \n    @staticmethod\n    def validate_language(language: Optional[str]) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        验证语言参数\n        \n        Args:\n            language: 语言代码\n            \n        Returns:\n            Tuple[bool, Optional[str]]: (是否有效, 错误信息)\n        \"\"\"\n        if language is None:\n            return True, None  # 语言是可选参数\n        \n        if not GreetingGenerator.is_language_supported(language):\n            supported = \", \".join(GreetingGenerator.SUPPORTED_LANGUAGES)\n            return False, f\"Unsupported language: {language}. Supported languages: {supported}\"\n        \n        return True, None\n    \n    @staticmethod\n    def validate_timezone(timezone: Optional[str]) -> Tuple[bool, Optional[str]]:\n        \"\"\"\n        验证时区参数\n        \n        Args:\n            timezone: 时区字符串\n            \n        Returns:\n            Tuple[bool, Optional[str]]: (是否有效, 错误信息)\n        \"\"\"\n        if timezone is None:\n            return True, None  # 时区是可选参数\n        \n        if not TimeProcessor.validate_timezone(timezone):\n            return False, f\"Invalid timezone format: {timezone}\"\n        \n        return True, None\n    \n    @staticmethod\n    def validate_greeting_request(request_data: Dict[str, Any]) -> Tuple[bool, Dict[str, Any], Optional[str]]:\n        \"\"\"\n        验证完整的问候请求\n        \n        Args:\n            request_data: 请求数据字典\n            \n        Returns:\n            Tuple[bool, Dict[str, Any], Optional[str]]: (是否有效, 处理后的请求数据, 错误信息)\n        \"\"\"\n        processed_data = {}\n        \n        # 验证name字段\n        name = request_data.get(\"name\", \"\")\n        is_valid, error = InputValidator.validate_name(name)\n        if not is_valid:\n            return False, {}, error\n        processed_data[\"name\"] = name\n        \n        # 验证language字段\n        language = request_data.get(\"language\", \"zh\")\n        is_valid, error = InputValidator.validate_language(language)\n        if not is_valid:\n            return False, {}, error\n        processed_data[\"language\"] = language or \"zh\"\n        \n        # 验证timezone字段\n        timezone = request_data.get(\"timezone\")\n        is_valid, error = InputValidator.validate_timezone(timezone)\n        if not is_valid:\n            return False, {}, error\n        processed_data[\"timezone\"] = timezone\n        \n        return True, processed_data, None\n```",
    
    "response_formatter": "```python\n# tools/generated_tools/response_formatter.py\n\nfrom typing import Dict, Any, Optional\nfrom .time_processor import TimeProcessor\nimport datetime\nimport json\n\nclass ResponseFormatter:\n    \"\"\"\n    响应格式化工具，用于构建标准化的API响应\n    \"\"\"\n    \n    @staticmethod\n    def format_success_response(message: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        格式化成功响应\n        \n        Args:\n            message: 响应消息\n            data: 响应数据\n            \n        Returns:\n            Dict[str, Any]: 格式化的响应字典\n        \"\"\"\n        return {\n            \"status\": \"success\",\n            \"message\": message,\n            \"data\": data\n        }\n    \n    @staticmethod\n    def format_error_response(error: str, error_code: str, details: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"\n        格式化错误响应\n        \n        Args:\n            error: 错误描述\n            error_code: 错误代码\n            details: 错误详细信息\n            \n        Returns:\n            Dict[str, Any]: 格式化的错误响应字典\n        \"\"\"\n        response = {\n            \"status\": \"error\",\n            \"error\": error,\n            \"error_code\": error_code,\n            \"timestamp\": TimeProcessor.format_timestamp(datetime.datetime.now())\n        }\n        \n        if details:\n            response[\"details\"] = details\n            \n        return response\n    \n    @staticmethod\n    def format_greeting_response(greeting: str, greeting_type: str, language: str, processing_time_ms: float) -> Dict[str, Any]:\n        \"\"\"\n        格式化问候响应\n        \n        Args:\n            greeting: 问候消息\n            greeting_type: 问候类型\n            language: 使用的语言\n            processing_time_ms: 处理时间(毫秒)\n            \n        Returns:\n            Dict[str, Any]: 格式化的问候响应\n        \"\"\"\n        data = {\n            \"greeting_type\": greeting_type,\n            \"language\": language,\n            \"timestamp\": TimeProcessor.format_timestamp(datetime.datetime.now()),\n            \"processing_time_ms\": processing_time_ms\n        }\n        \n        return ResponseFormatter.format_success_response(greeting, data)\n    \n    @staticmethod\n    def format_health_response(is_healthy: bool, version: str, uptime_seconds: float, metrics: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        格式化健康检查响应\n        \n        Args:\n            is_healthy: 服务是否健康\n            version: 服务版本\n            uptime_seconds: 运行时间(秒)\n            metrics: 服务指标\n            \n        Returns:\n            Dict[str, Any]: 格式化的健康检查响应\n        \"\"\"\n        return {\n            \"status\": \"healthy\" if is_healthy else \"unhealthy\",\n            \"version\": version,\n            \"uptime\": TimeProcessor.format_uptime(uptime_seconds),\n            \"timestamp\": TimeProcessor.format_timestamp(datetime.datetime.now()),\n            \"metrics\": metrics\n        }\n```",
    
    "metrics_collector": "```python\n# tools/generated_tools/metrics_collector.py\n\nfrom typing import Dict, Any, List, Optional\nimport time\nimport threading\nimport statistics\n\nclass MetricsCollector:\n    \"\"\"\n    指标收集工具，用于收集和计算API性能指标\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"\n        初始化指标收集器\n        \"\"\"\n        self._start_time = time.time()\n        self._request_count = 0\n        self._response_times = []\n        self._response_times_lock = threading.Lock()\n        self._error_count = 0\n        self._endpoint_stats = {}\n    \n    def record_request(self, endpoint: str, start_time: float, status_code: int, error: Optional[str] = None) -> None:\n        \"\"\"\n        记录一个API请求\n        \n        Args:\n            endpoint: API端点路径\n            start_time: 请求开始时间戳\n            status_code: HTTP状态码\n            error: 错误信息(如果有)\n        \"\"\"\n        end_time = time.time()\n        response_time = (end_time - start_time) * 1000  # 转换为毫秒\n        \n        with self._response_times_lock:\n            self._request_count += 1\n            self._response_times.append(response_time)\n            \n            # 记录端点统计信息\n            if endpoint not in self._endpoint_stats:\n                self._endpoint_stats[endpoint] = {\n                    \"count\": 0,\n                    \"response_times\": [],\n                    \"errors\": 0\n                }\n            \n            self._endpoint_stats[endpoint][\"count\"] += 1\n            self._endpoint_stats[endpoint][\"response_times\"].append(response_time)\n            \n            if error or status_code >= 400:\n                self._error_count += 1\n                self._endpoint_stats[endpoint][\"errors\"] += 1\n    \n    def get_uptime(self) -> float:\n        \"\"\"\n        获取服务运行时间（秒）\n        \n        Returns:\n            float: 运行时间秒数\n        \"\"\"\n        return time.time() - self._start_time\n    \n    def get_request_count(self) -> int:\n        \"\"\"\n        获取总请求数\n        \n        Returns:\n            int: 总请求数\n        \"\"\"\n        return self._request_count\n    \n    def get_error_rate(self) -> float:\n        \"\"\"\n        获取错误率\n        \n        Returns:\n            float: 错误率（0-1之间的小数）\n        \"\"\"\n        if self._request_count == 0:\n            return 0.0\n        return self._error_count / self._request_count\n    \n    def get_avg_response_time(self) -> float:\n        \"\"\"\n        获取平均响应时间（毫秒）\n        \n        Returns:\n            float: 平均响应时间\n        \"\"\"\n        if not self._response_times:\n            return 0.0\n        return statistics.mean(self._response_times)\n    \n    def get_p95_response_time(self) -> float:\n        \"\"\"\n        获取P95响应时间（毫秒）\n        \n        Returns:\n            float: P95响应时间\n        \"\"\"\n        if not self._response_times:\n            return 0.0\n        sorted_times = sorted(self._response_times)\n        idx = int(len(sorted_times) * 0.95)\n        return sorted_times[idx]\n    \n    def get_metrics_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        获取指标摘要\n        \n        Returns:\n            Dict[str, Any]: 包含各种指标的字典\n        \"\"\"\n        with self._response_times_lock:\n            return {\n                \"total_requests\": self._request_count,\n                \"error_rate\": self.get_error_rate(),\n                \"avg_response_time\": self.get_avg_response_time(),\n                \"p95_response_time\": self.get_p95_response_time(),\n                \"uptime_seconds\": self.get_uptime()\n            }\n```",
    
    "logger": "```python\n# tools/generated_tools/logger.py\n\nimport logging\nimport json\nfrom typing import Dict, Any, Optional\nimport datetime\nimport os\nimport sys\n\nclass Logger:\n    \"\"\"\n    日志记录工具，提供结构化日志记录功能\n    \"\"\"\n    \n    # 日志级别映射\n    LOG_LEVELS = {\n        \"debug\": logging.DEBUG,\n        \"info\": logging.INFO,\n        \"warning\": logging.WARNING,\n        \"error\": logging.ERROR,\n        \"critical\": logging.CRITICAL\n    }\n    \n    @staticmethod\n    def setup_logger(name: str = \"greeting_api\", level: str = \"info\", \n                    log_format: str = \"json\", log_file: Optional[str] = None) -> logging.Logger:\n        \"\"\"\n        设置日志记录器\n        \n        Args:\n            name: 日志记录器名称\n            level: 日志级别 (debug, info, warning, error, critical)\n            log_format: 日志格式 (json, text)\n            log_file: 日志文件路径，如不提供则输出到标准输出\n            \n        Returns:\n            logging.Logger: 配置好的日志记录器\n        \"\"\"\n        logger = logging.getLogger(name)\n        \n        # 设置日志级别\n        log_level = Logger.LOG_LEVELS.get(level.lower(), logging.INFO)\n        logger.setLevel(log_level)\n        \n        # 清除现有的处理器\n        if logger.handlers:\n            for handler in logger.handlers:\n                logger.removeHandler(handler)\n        \n        # 创建处理器\n        if log_file:\n            handler = logging.FileHandler(log_file)\n        else:\n            handler = logging.StreamHandler(sys.stdout)\n        \n        # 设置日志格式\n        if log_format.lower() == \"json\":\n            formatter = logging.Formatter(\"%(message)s\")\n            # 使用自定义的JSONFormatter\n            handler.setFormatter(JSONFormatter())\n        else:\n            formatter = logging.Formatter(\n                \"[%(asctime)s] [%(levelname)s] [%(name)s] %(message)s\"\n            )\n            handler.setFormatter(formatter)\n        \n        logger.addHandler(handler)\n        return logger\n    \n    @staticmethod\n    def sanitize_log_data(data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        对日志数据进行脱敏处理\n        \n        Args:\n            data: 原始日志数据\n            \n        Returns:\n            Dict[str, Any]: 脱敏后的日志数据\n        \"\"\"\n        # 复制一份数据进行处理，避免修改原始数据\n        sanitized = data.copy()\n        \n        # 定义敏感字段和脱敏规则\n        sensitive_fields = [\"password\", \"token\", \"api_key\", \"secret\"]\n        \n        # 遍历字典进行脱敏\n        for key in sanitized.keys():\n            if any(sensitive in key.lower() for sensitive in sensitive_fields):\n                sanitized[key] = \"*****\"\n        \n        return sanitized\n\n\nclass JSONFormatter(logging.Formatter):\n    \"\"\"\n    自定义JSON格式日志格式化器\n    \"\"\"\n    \n    def format(self, record):\n        \"\"\"\n        将日志记录格式化为JSON字符串\n        \"\"\"\n        log_data = {\n            \"timestamp\": datetime.datetime.now().isoformat(),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"line\": record.lineno\n        }\n        \n        # 添加异常信息（如果有）\n        if record.exc_info:\n            log_data[\"exception\"] = self.formatException(record.exc_info)\n        \n        # 添加额外的上下文信息\n        if hasattr(record, \"data\") and isinstance(record.data, dict):\n            # 对敏感数据进行脱敏处理\n            sanitized_data = Logger.sanitize_log_data(record.data)\n            log_data.update(sanitized_data)\n        \n        return json.dumps(log_data)\n```"
  }
}