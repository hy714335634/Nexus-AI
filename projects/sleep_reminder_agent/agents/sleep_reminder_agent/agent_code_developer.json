# 睡眠提醒Agent代码开发

## 代码开发概述

根据需求分析、系统架构、Agent设计、工具开发和提示词工程的成果，完成了睡眠提醒Agent的代码实现。代码实现了所有核心功能，包括睡眠时间设置、个性化提醒、多种通知方式、重复提醒规则、用户偏好学习和提醒历史管理。

## 代码架构

睡眠提醒Agent的代码架构包括以下主要组件：

1. **主Agent类 (SleepReminderAgent)**：负责处理用户请求和调用相应工具
2. **交互模式**：支持命令行交互和API服务两种模式
3. **工具集成**：与TimeManager、NotificationManager、DataManager、MessageTemplateManager、UserPreferenceManager和ReminderScheduler等工具的集成
4. **意图识别系统**：基于正则表达式的简单意图识别机制
5. **错误处理机制**：全面的异常捕获和处理

## 主要功能实现

### 1. 睡眠时间设置

实现了完整的睡眠时间设置功能，包括：
- 时间格式验证
- 用户配置更新
- 提醒调度安排
- 用户友好的反馈

### 2. 提醒方式配置

支持多种提醒方式的配置：
- 文本提醒
- 声音提醒
- 弹窗提醒
- 多种方式组合

### 3. 重复提醒规则

实现了灵活的重复提醒规则设置：
- 可配置的间隔时间
- 可配置的最大重复次数
- 用户响应后自动取消后续重复

### 4. 提醒历史管理

提供全面的历史记录功能：
- 记录所有提醒事件
- 统计分析用户响应情况
- 生成有意义的历史摘要

### 5. 用户偏好学习

实现了智能的用户偏好学习机制：
- 分析用户行为模式
- 识别最有效的提醒方式
- 生成优化建议
- 支持自动应用优化

## 代码实现

### sleep_reminder_agent.py

```python
# sleep_reminder_agent.py
"""
睡眠提醒Agent - 帮助用户建立健康的睡眠习惯的智能助手
"""

import os
import re
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Union
import threading
import time

# 导入工具模块
from sleep_reminder_tools import (
    TimeManager,
    NotificationManager,
    DataManager,
    MessageTemplateManager,
    UserPreferenceManager,
    ReminderScheduler
)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("sleep_reminder_agent")

class SleepReminderAgent:
    """睡眠提醒Agent，帮助用户建立健康的睡眠习惯"""
    
    def __init__(self, data_dir: str = "data"):
        """
        初始化睡眠提醒Agent
        
        Args:
            data_dir: 数据存储目录
        """
        logger.info("初始化睡眠提醒Agent...")
        
        # 初始化工具
        self.data_manager = DataManager(storage_dir=data_dir)
        self.message_manager = MessageTemplateManager(self.data_manager)
        self.preference_manager = UserPreferenceManager(self.data_manager)
        self.notification_manager = NotificationManager()
        self.scheduler = ReminderScheduler(
            self.data_manager,
            self.message_manager,
            self.notification_manager
        )
        
        # 加载用户配置
        self.user_config = self.data_manager.get_user_config()
        
        # 意图识别模式
        self.intent_patterns = {
            "set_sleep_time": [
                r"设置.*睡眠时间.*(\d{1,2})[:.：](\d{1,2})",
                r"设置.*提醒.*(\d{1,2})[:.：](\d{1,2})",
                r"我想.*(\d{1,2})[:.：](\d{1,2}).*睡觉",
                r"(\d{1,2})[:.：](\d{1,2}).*睡觉",
                r"睡眠时间.*改为.*(\d{1,2})[:.：](\d{1,2})"
            ],
            "set_reminder_method": [
                r"(提醒|通知)方式",
                r"(文本|声音|弹窗).*提醒",
                r"用.*(文本|声音|弹窗).*提醒"
            ],
            "set_repeat_reminder": [
                r"重复提醒",
                r"再次提醒",
                r"如果.*没.*回应",
                r"提醒.*(\d+).*次",
                r"每.*(\d+).*分钟.*提醒"
            ],
            "query_next_reminder": [
                r"下一?次.*提醒",
                r"什么时候.*提醒",
                r"几点.*提醒",
                r"还有多久"
            ],
            "query_history": [
                r"历史记录",
                r"提醒记录",
                r"睡眠记录",
                r"睡眠情况",
                r"查看记录"
            ],
            "clear_data": [
                r"清除.*数据",
                r"删除.*记录",
                r"清空.*历史",
                r"重置.*设置"
            ],
            "sleep_advice": [
                r"睡眠建议",
                r"如何.*睡得好",
                r"睡眠质量",
                r"失眠",
                r"睡不着",
                r"入睡"
            ],
            "respond_to_reminder": [
                r"收到.*提醒",
                r"我看到了.*提醒",
                r"谢谢.*提醒",
                r"提醒.*收到"
            ],
            "greeting": [
                r"你好",
                r"早上好",
                r"晚上好",
                r"嗨",
                r"哈喽"
            ],
            "help": [
                r"帮助",
                r"使用说明",
                r"怎么用",
                r"功能",
                r"你能做什么"
            ]
        }
        
        # 启动提醒调度器
        if self.user_config.get("sleep_time"):
            self.scheduler.schedule_reminder()
            logger.info("已启动提醒调度器")
        else:
            logger.info("未设置睡眠时间，提醒调度器未启动")
    
    def process_message(self, user_message: str) -> str:
        """
        处理用户消息
        
        Args:
            user_message: 用户输入的消息
            
        Returns:
            Agent的回复
        """
        try:
            # 识别意图
            intent, entities = self._recognize_intent(user_message)
            logger.info(f"识别到意图: {intent}, 实体: {entities}")
            
            # 根据意图处理请求
            if intent == "set_sleep_time":
                return self._handle_set_sleep_time(entities)
            elif intent == "set_reminder_method":
                return self._handle_set_reminder_method(user_message, entities)
            elif intent == "set_repeat_reminder":
                return self._handle_set_repeat_reminder(user_message, entities)
            elif intent == "query_next_reminder":
                return self._handle_query_next_reminder()
            elif intent == "query_history":
                return self._handle_query_history()
            elif intent == "clear_data":
                return self._handle_clear_data(user_message)
            elif intent == "sleep_advice":
                return self._handle_sleep_advice()
            elif intent == "respond_to_reminder":
                return self._handle_respond_to_reminder()
            elif intent == "greeting":
                return self._handle_greeting()
            elif intent == "help":
                return self._handle_help()
            else:
                return self._handle_unknown_intent(user_message)
        except Exception as e:
            logger.error(f"处理消息时出错: {str(e)}", exc_info=True)
            return f"抱歉，处理您的请求时遇到了问题。请尝试使用更清晰的表述，或者输入'帮助'查看使用指南。错误详情: {str(e)}"
    
    def _recognize_intent(self, message: str) -> Tuple[str, Dict]:
        """
        识别用户消息的意图和实体
        
        Args:
            message: 用户消息
            
        Returns:
            意图和实体的元组
        """
        # 默认意图和实体
        intent = "unknown"
        entities = {}
        
        # 检查每种意图模式
        for intent_name, patterns in self.intent_patterns.items():
            for pattern in patterns:
                matches = re.search(pattern, message)
                if matches:
                    intent = intent_name
                    
                    # 提取实体
                    if intent == "set_sleep_time" and len(matches.groups()) >= 2:
                        hour = int(matches.group(1))
                        minute = int(matches.group(2))
                        # 处理12小时制
                        if "晚上" in message or "下午" in message or "傍晚" in message or "晚" in message:
                            if hour < 12:
                                hour += 12
                        elif "早上" in message or "凌晨" in message or "早晨" in message:
                            if hour == 12:
                                hour = 0
                        
                        time_str = f"{hour:02d}:{minute:02d}"
                        entities["time"] = time_str
                    
                    elif intent == "set_reminder_method":
                        methods = []
                        if "文本" in message:
                            methods.append("text")
                        if "声音" in message:
                            methods.append("sound")
                        if "弹窗" in message:
                            methods.append("popup")
                        entities["methods"] = methods
                    
                    elif intent == "set_repeat_reminder":
                        # 提取分钟数
                        minutes_match = re.search(r"(\d+).*分钟", message)
                        if minutes_match:
                            entities["interval_minutes"] = int(minutes_match.group(1))
                        
                        # 提取重复次数
                        times_match = re.search(r"(\d+).*次", message)
                        if times_match:
                            entities["max_repeats"] = int(times_match.group(1))
                    
                    return intent, entities
        
        return intent, entities
    
    def _handle_set_sleep_time(self, entities: Dict) -> str:
        """处理设置睡眠时间请求"""
        time_str = entities.get("time")
        
        if not time_str:
            return "请提供有效的睡眠时间，格式为HH:MM，例如22:30表示晚上10点30分。"
        
        # 验证时间格式
        if not TimeManager.validate_time_format(time_str):
            return f"时间格式无效: {time_str}。请使用HH:MM格式，例如22:30表示晚上10点30分。"
        
        # 更新用户配置
        self.data_manager.update_user_config({"sleep_time": time_str})
        self.user_config = self.data_manager.get_user_config()
        
        # 安排提醒
        result = self.scheduler.schedule_reminder()
        
        if result.get("scheduled"):
            next_reminder_time = result.get("next_reminder")
            time_until = result.get("time_until")
            
            # 获取当前提醒方式
            methods = self.user_config.get("reminder_methods", ["text"])
            methods_str = "、".join([
                {"text": "文本", "sound": "声音", "popup": "弹窗"}.get(m, m) 
                for m in methods
            ])
            
            response = f"已将您的睡眠提醒时间设置为{time_str}。下次提醒将在{time_until}后发送，使用{methods_str}方式提醒。"
            
            # 如果没有设置重复提醒，建议设置
            if not self.user_config.get("repeat_rules", {}).get("enabled", False):
                response += "\n\n您还没有设置重复提醒规则。如果您希望在错过第一次提醒时收到重复提醒，可以说"设置重复提醒"。"
                
            return response
        else:
            return f"设置睡眠时间时出现问题: {result.get('error', '未知错误')}。请稍后再试。"
    
    def _handle_set_reminder_method(self, message: str, entities: Dict) -> str:
        """处理设置提醒方式请求"""
        methods = entities.get("methods", [])
        
        # 如果没有从实体中提取到方法，尝试从消息中识别
        if not methods:
            if "文本" in message:
                methods.append("text")
            if "声音" in message:
                methods.append("sound")
            if "弹窗" in message:
                methods.append("popup")
        
        # 如果仍然没有识别到方法，返回可用选项
        if not methods:
            return "请指定您希望使用的提醒方式，可选项有：文本、声音、弹窗。例如"使用声音和弹窗提醒"。"
        
        # 验证方法是否受支持
        valid_methods = []
        for method in methods:
            if method in NotificationManager.NOTIFICATION_METHODS:
                valid_methods.append(method)
        
        if not valid_methods:
            return "您指定的提醒方式不受支持。目前支持的提醒方式有：文本、声音、弹窗。"
        
        # 更新用户配置
        self.data_manager.update_user_config({"reminder_methods": valid_methods})
        self.user_config = self.data_manager.get_user_config()
        
        # 生成方法的中文名称
        methods_str = "、".join([
            {"text": "文本", "sound": "声音", "popup": "弹窗"}.get(m, m) 
            for m in valid_methods
        ])
        
        response = f"已将您的提醒方式设置为{methods_str}。下次提醒将使用这些方式发送。"
        
        # 如果已设置睡眠时间，提供下次提醒信息
        if self.user_config.get("sleep_time"):
            next_reminder = TimeManager.get_next_reminder_time(self.user_config["sleep_time"])
            time_until = TimeManager.format_time_delta(TimeManager.get_time_until_reminder(self.user_config["sleep_time"]))
            response += f"\n\n下次提醒将在{time_until}后发送。"
        else:
            response += "\n\n您还没有设置睡眠时间。请设置睡眠时间以开始接收提醒。"
            
        return response
    
    def _handle_set_repeat_reminder(self, message: str, entities: Dict) -> str:
        """处理设置重复提醒请求"""
        interval_minutes = entities.get("interval_minutes")
        max_repeats = entities.get("max_repeats")
        
        # 如果没有提取到参数，尝试从消息中解析
        if not interval_minutes:
            minutes_match = re.search(r"(\d+).*分钟", message)
            if minutes_match:
                interval_minutes = int(minutes_match.group(1))
            else:
                interval_minutes = 10  # 默认值
        
        if not max_repeats:
            times_match = re.search(r"(\d+).*次", message)
            if times_match:
                max_repeats = int(times_match.group(1))
            else:
                max_repeats = 3  # 默认值
        
        # 更新用户配置
        repeat_rules = {
            "enabled": True,
            "interval_minutes": interval_minutes,
            "max_repeats": max_repeats
        }
        self.data_manager.update_user_config({"repeat_rules": repeat_rules})
        self.user_config = self.data_manager.get_user_config()
        
        response = f"已设置重复提醒规则。如果您没有响应第一次提醒，系统将每{interval_minutes}分钟再次提醒您，最多重复{max_repeats}次。"
        
        # 如果已设置睡眠时间，提供下次提醒信息
        if self.user_config.get("sleep_time"):
            next_reminder = TimeManager.get_next_reminder_time(self.user_config["sleep_time"])
            time_until = TimeManager.format_time_delta(TimeManager.get_time_until_reminder(self.user_config["sleep_time"]))
            response += f"\n\n下次提醒将在{time_until}后发送。"
        else:
            response += "\n\n您还没有设置睡眠时间。请设置睡眠时间以开始接收提醒。"
            
        return response
    
    def _handle_query_next_reminder(self) -> str:
        """处理查询下次提醒请求"""
        sleep_time = self.user_config.get("sleep_time")
        
        if not sleep_time:
            return "您还没有设置睡眠时间。请设置睡眠时间以开始接收提醒。"
        
        try:
            next_reminder = TimeManager.get_next_reminder_time(sleep_time)
            time_until = TimeManager.format_time_delta(TimeManager.get_time_until_reminder(sleep_time))
            
            # 获取当前提醒方式
            methods = self.user_config.get("reminder_methods", ["text"])
            methods_str = "、".join([
                {"text": "文本", "sound": "声音", "popup": "弹窗"}.get(m, m) 
                for m in methods
            ])
            
            # 获取重复提醒设置
            repeat_rules = self.user_config.get("repeat_rules", {})
            repeat_enabled = repeat_rules.get("enabled", False)
            
            response = f"根据您的设置，下一次睡眠提醒将在{next_reminder.strftime('%Y-%m-%d %H:%M')}发送，距离现在还有{time_until}。"
            response += f"\n\n您设置的提醒方式是{methods_str}。"
            
            if repeat_enabled:
                interval = repeat_rules.get("interval_minutes", 10)
                max_times = repeat_rules.get("max_repeats", 3)
                response += f"\n\n如果您没有响应第一次提醒，系统将每{interval}分钟再次提醒您，最多重复{max_times}次。"
            else:
                response += "\n\n您没有启用重复提醒。如果需要，可以说"设置重复提醒"。"
                
            return response
        except Exception as e:
            logger.error(f"计算下次提醒时间出错: {str(e)}")
            return f"计算下次提醒时间时出现问题: {str(e)}。请确保您的睡眠时间设置正确。"
    
    def _handle_query_history(self) -> str:
        """处理查询历史记录请求"""
        history = self.data_manager.get_reminder_history()
        
        if not history:
            return "您还没有任何睡眠提醒记录。设置睡眠时间后，系统将开始记录提醒历史。"
        
        # 分析历史数据
        total_reminders = len(history)
        responded_reminders = sum(1 for item in history if item.get("user_response"))
        response_rate = responded_reminders / total_reminders if total_reminders > 0 else 0
        
        # 计算最近7天的记录
        recent_history = []
        now = datetime.now()
        for item in history:
            try:
                sent_time = datetime.fromisoformat(item.get("actual_sent_time", ""))
                if (now - sent_time).days <= 7:
                    recent_history.append(item)
            except (ValueError, TypeError):
                continue
        
        recent_count = len(recent_history)
        
        # 分析响应时间
        response_times = []
        for item in history:
            if item.get("user_response") and item.get("response_time") and item.get("actual_sent_time"):
                try:
                    sent_time = datetime.fromisoformat(item["actual_sent_time"])
                    response_time = datetime.fromisoformat(item["response_time"])
                    response_times.append((response_time - sent_time).total_seconds() / 60)  # 转换为分钟
                except (ValueError, TypeError):
                    continue
                
        avg_response_time = sum(response_times) / len(response_times) if response_times else None
        
        # 分析最有效的提醒方式
        method_success = {}
        for item in history:
            method = item.get("method_used")
            responded = bool(item.get("user_response"))
            
            if method:
                if method not in method_success:
                    method_success[method] = {"responded": 0, "total": 0}
                    
                method_success[method]["total"] += 1
                if responded:
                    method_success[method]["responded"] += 1
        
        # 计算各方式的响应率
        method_response_rate = {}
        best_method = None
        best_rate = 0
        
        for method, stats in method_success.items():
            if stats["total"] > 0:
                rate = stats["responded"] / stats["total"]
                method_response_rate[method] = rate
                if rate > best_rate:
                    best_rate = rate
                    best_method = method
        
        # 生成响应
        response = f"在您的睡眠提醒历史中，共有{total_reminders}条记录，其中{responded_reminders}次有响应，总体响应率为{response_rate:.0%}。"
        
        if recent_count > 0:
            response += f"\n\n在过去7天内，系统共发送了{recent_count}次提醒。"
            
        if avg_response_time is not None:
            response += f"\n\n您的平均响应时间为{avg_response_time:.1f}分钟。"
            
        if best_method:
            best_method_name = {"text": "文本", "sound": "声音", "popup": "弹窗"}.get(best_method, best_method)
            response += f"\n\n您对{best_method_name}提醒的响应率最高，为{best_rate:.0%}。"
        
        # 添加优化建议
        analysis = self.preference_manager.analyze_user_behavior()
        if analysis.get("patterns_found") and analysis.get("recommendations"):
            response += "\n\n基于您的使用习惯，系统有以下建议："
            for i, rec in enumerate(analysis["recommendations"], 1):
                response += f"\n{i}. {rec['message']}"
            
            response += "\n\n您希望系统自动应用这些优化建议吗？"
        
        return response
    
    def _handle_clear_data(self, message: str) -> str:
        """处理清除数据请求"""
        # 检查是否是确认删除的消息
        if "确定" in message or "确认" in message:
            success = self.data_manager.clear_user_data()
            if success:
                # 重新加载配置
                self.user_config = self.data_manager.get_user_config()
                return "已成功清除您的所有睡眠提醒数据和设置。您的隐私得到了保护。如果您希望重新开始使用睡眠提醒服务，可以随时设置新的睡眠时间。"
            else:
                return "清除数据时出现问题。请稍后再试。"
        else:
            return "您确定要删除所有睡眠提醒记录和设置吗？这将清除您的所有历史数据和个性化设置，此操作无法撤销。如果确定，请回复"确认删除"。"
    
    def _handle_sleep_advice(self) -> str:
        """处理睡眠建议请求"""
        advice = [
            "保持规律的睡眠时间表，包括周末",
            "创建舒适的睡眠环境：安静、黑暗、凉爽",
            "睡前限制屏幕使用，蓝光可能会抑制褪黑激素的产生",
            "避免睡前摄入咖啡因和大量食物",
            "尝试睡前放松活动，如阅读或冥想",
            "白天保持适当的体育活动，但避免睡前剧烈运动",
            "如果无法入睡，不要躺在床上翻来覆去，起床做些放松活动直到感到困倦",
            "保持规律的起床时间，即使前一晚睡得晚",
            "避免长时间午睡，最好控制在30分钟以内",
            "睡前避免饮酒，酒精可能帮助入睡但会影响睡眠质量"
        ]
        
        response = "以下是一些可能帮助改善睡眠质量的一般建议：\n\n"
        for i, tip in enumerate(advice, 1):
            response += f"{i}. {tip}\n"
            
        response += "\n这些只是一般性建议，不构成医疗建议。如果您持续面临睡眠问题，建议咨询医疗专业人士。"
        
        # 如果已设置睡眠时间，提供下次提醒信息
        if self.user_config.get("sleep_time"):
            next_reminder = TimeManager.get_next_reminder_time(self.user_config["sleep_time"])
            time_until = TimeManager.format_time_delta(TimeManager.get_time_until_reminder(self.user_config["sleep_time"]))
            response += f"\n\n根据您的设置，下次睡眠提醒将在{time_until}后发送。"
            
        return response
    
    def _handle_respond_to_reminder(self) -> str:
        """处理响应提醒请求"""
        # 获取最近的提醒
        history = self.data_manager.get_reminder_history()
        
        if not history:
            return "您还没有收到过任何睡眠提醒。设置睡眠时间后，系统将开始发送提醒。"
        
        # 找到最近的未响应提醒
        latest_reminder = None
        for item in reversed(history):
            if not item.get("user_response"):
                latest_reminder = item
                break
        
        if not latest_reminder:
            return "没有找到未响应的提醒。您的所有提醒都已得到响应。"
        
        # 记录响应
        reminder_id = latest_reminder.get("id")
        if reminder_id:
            self.scheduler.record_user_response(reminder_id, "acknowledged")
            
            # 根据时间给出不同回复
            try:
                sent_time = datetime.fromisoformat(latest_reminder.get("actual_sent_time", ""))
                now = datetime.now()
                minutes_passed = (now - sent_time).total_seconds() / 60
                
                if minutes_passed < 5:
                    return "很高兴您及时响应了提醒！已记录您的回应。希望您能享受一个舒适的睡眠。明天的提醒将在同一时间发送。祝您好梦！"
                elif minutes_passed < 30:
                    return "感谢您响应提醒！已记录您的回应。虽然有些延迟，但仍然在合理范围内。希望您能尽快准备休息。祝您好梦！"
                else:
                    return "已记录您的响应。看起来您响应提醒的时间有些晚。如果这是因为没有及时注意到提醒，您可以考虑更改提醒方式或设置重复提醒。祝您好梦！"
            except:
                return "已记录您的响应。希望您能享受一个舒适的睡眠。明天的提醒将在同一时间发送。祝您好梦！"
        else:
            return "记录响应时出现问题。但不用担心，系统仍会继续为您提供睡眠提醒服务。"
    
    def _handle_greeting(self) -> str:
        """处理问候请求"""
        # 根据当前时间生成不同的问候语
        hour = datetime.now().hour
        
        if 5 <= hour < 12:
            greeting = "早上好！"
        elif 12 <= hour < 18:
            greeting = "下午好！"
        else:
            greeting = "晚上好！"
            
        response = f"{greeting}我是您的睡眠提醒助手，可以帮助您建立健康的睡眠习惯。"
        
        # 如果已设置睡眠时间，提供下次提醒信息
        if self.user_config.get("sleep_time"):
            next_reminder = TimeManager.get_next_reminder_time(self.user_config["sleep_time"])
            time_until = TimeManager.format_time_delta(TimeManager.get_time_until_reminder(self.user_config["sleep_time"]))
            response += f"\n\n根据您的设置，下次睡眠提醒将在{time_until}后发送。"
        else:
            response += "\n\n您还没有设置睡眠时间。您可以说"设置睡眠时间"来开始使用提醒服务。"
            
        return response
    
    def _handle_help(self) -> str:
        """处理帮助请求"""
        help_text = """
我是您的睡眠提醒助手，可以帮助您建立健康的睡眠习惯。以下是我能为您提供的主要功能：

1. 设置睡眠时间 - 例如："设置睡眠时间为22:30"
2. 配置提醒方式 - 例如："使用声音和弹窗提醒我"
3. 设置重复提醒 - 例如："如果我没回应，每15分钟提醒我一次，最多3次"
4. 查询下次提醒 - 例如："我的下一次提醒是什么时候？"
5. 查看历史记录 - 例如："查看我的睡眠记录"
6. 获取睡眠建议 - 例如："有什么方法可以帮助我更好地入睡？"
7. 清除数据 - 例如："删除我所有的睡眠记录"

您可以随时使用这些功能来管理您的睡眠提醒。如果有任何问题，请直接询问我。
        """
        return help_text.strip()
    
    def _handle_unknown_intent(self, message: str) -> str:
        """处理未知意图"""
        # 尝试理解用户可能的意图
        sleep_related = any(word in message for word in ["睡眠", "睡觉", "提醒", "闹钟"])
        
        if sleep_related:
            return "抱歉，我没有完全理解您的请求。您是想设置睡眠提醒、查询提醒状态，还是需要睡眠建议？您可以说"帮助"查看我能提供的功能。"
        else:
            return "抱歉，我是一个专注于睡眠提醒的助手，可能无法处理这个请求。您可以说"帮助"查看我能提供的功能。"


# 命令行交互模式
def interactive_mode():
    """启动命令行交互模式"""
    print("睡眠提醒助手已启动。输入'退出'结束对话。")
    
    agent = SleepReminderAgent()
    
    while True:
        user_input = input("\n您: ")
        
        if user_input.lower() in ["退出", "exit", "quit"]:
            print("谢谢使用睡眠提醒助手，祝您好梦！")
            break
            
        response = agent.process_message(user_input)
        print(f"\n助手: {response}")


# API服务模式
def start_api_server(host="0.0.0.0", port=5000):
    """启动API服务"""
    try:
        from flask import Flask, request, jsonify
        
        app = Flask("SleepReminderAgent")
        agent = SleepReminderAgent()
        
        @app.route("/chat", methods=["POST"])
        def chat():
            data = request.json
            user_message = data.get("message", "")
            
            if not user_message:
                return jsonify({"error": "No message provided"}), 400
                
            response = agent.process_message(user_message)
            return jsonify({"response": response})
        
        @app.route("/health", methods=["GET"])
        def health():
            return jsonify({"status": "ok"})
        
        print(f"睡眠提醒助手API服务已启动，监听 {host}:{port}")
        app.run(host=host, port=port)
    except ImportError:
        print("启动API服务需要安装Flask。请使用'pip install flask'安装。")
        return


# 主函数
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--api":
        # API服务模式
        port = int(sys.argv[2]) if len(sys.argv) > 2 else 5000
        start_api_server(port=port)
    else:
        # 交互模式
        interactive_mode()
```

### app.py (Web API接口)

```python
# app.py
"""
睡眠提醒Agent的Web API接口
"""

import os
import json
import logging
from flask import Flask, request, jsonify, render_template
from sleep_reminder_agent import SleepReminderAgent

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("sleep_reminder_api")

# 初始化Flask应用
app = Flask(__name__)

# 初始化Agent
data_dir = os.environ.get("DATA_DIR", "data")
agent = SleepReminderAgent(data_dir=data_dir)

@app.route("/")
def index():
    """首页"""
    return render_template("index.html")

@app.route("/api/chat", methods=["POST"])
def chat():
    """处理聊天请求"""
    try:
        data = request.json
        user_message = data.get("message", "")
        
        if not user_message:
            return jsonify({"error": "No message provided"}), 400
            
        response = agent.process_message(user_message)
        return jsonify({"response": response})
    except Exception as e:
        logger.error(f"处理聊天请求时出错: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@app.route("/api/config", methods=["GET"])
def get_config():
    """获取当前配置"""
    try:
        config = agent.data_manager.get_user_config()
        return jsonify(config)
    except Exception as e:
        logger.error(f"获取配置时出错: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@app.route("/api/history", methods=["GET"])
def get_history():
    """获取提醒历史"""
    try:
        history = agent.data_manager.get_reminder_history()
        return jsonify(history)
    except Exception as e:
        logger.error(f"获取历史记录时出错: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@app.route("/api/analysis", methods=["GET"])
def get_analysis():
    """获取用户行为分析"""
    try:
        analysis = agent.preference_manager.analyze_user_behavior()
        return jsonify(analysis)
    except Exception as e:
        logger.error(f"获取分析结果时出错: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@app.route("/api/optimize", methods=["POST"])
def optimize_preferences():
    """优化用户偏好"""
    try:
        result = agent.preference_manager.optimize_user_experience()
        return jsonify(result)
    except Exception as e:
        logger.error(f"优化用户偏好时出错: {str(e)}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@app.route("/api/health", methods=["GET"])
def health():
    """健康检查"""
    return jsonify({"status": "ok"})

if __name__ == "__main__":
    # 获取端口
    port = int(os.environ.get("PORT", 5000))
    
    # 是否开发模式
    debug = os.environ.get("DEBUG", "False").lower() == "true"
    
    # 启动服务
    app.run(host="0.0.0.0", port=port, debug=debug)
```

## 依赖项

为了确保代码能够正常运行，需要以下依赖项：

```
flask==2.0.1
python-dotenv==0.19.0
schedule==1.1.0
```

## 代码特性

### 1. 意图识别系统

使用正则表达式实现了简单但有效的意图识别系统，能够从用户输入中提取关键信息：

- 识别10种不同的用户意图
- 从文本中提取时间、提醒方式等实体
- 支持模糊匹配和同义词识别

### 2. 错误处理机制

实现了全面的错误处理机制，确保系统在各种异常情况下仍能正常运行：

- 全局异常捕获
- 详细的错误日志记录
- 用户友好的错误消息
- 自动恢复和降级策略

### 3. 多种运行模式

支持两种不同的运行模式，满足不同的使用场景：

- 命令行交互模式：适合本地测试和直接使用
- API服务模式：适合集成到其他应用或提供Web界面

### 4. 个性化响应

根据用户的具体情况提供个性化的响应：

- 根据当前时间调整问候语
- 根据用户响应时间给出不同的反馈
- 基于历史数据提供针对性的建议
- 自动学习和应用用户偏好

## 代码使用说明

### 1. 命令行模式

```bash
python sleep_reminder_agent.py
```

### 2. API服务模式

```bash
python sleep_reminder_agent.py --api [端口号]
```

或者使用Flask应用：

```bash
python app.py
```

### 3. 环境变量配置

可以通过环境变量配置以下参数：

- `DATA_DIR`：数据存储目录
- `PORT`：API服务端口
- `DEBUG`：是否开启调试模式

## 未来扩展计划

1. 添加更高级的自然语言处理能力
2. 集成机器学习模型进行更精准的用户偏好学习
3. 支持多用户和账户系统
4. 添加更丰富的睡眠统计和分析功能
5. 开发移动应用和桌面客户端