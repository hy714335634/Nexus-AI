# 睡眠提醒Agent工具开发

## 工具概述

为睡眠提醒Agent开发了以下六个核心工具：

1. **TimeManager**: 时间管理工具，用于设置、验证和计算睡眠提醒时间
2. **NotificationManager**: 通知工具，支持多种提醒方式（文本、声音、弹窗）
3. **DataManager**: 数据存储工具，管理用户配置和历史记录
4. **MessageTemplateManager**: 消息模板工具，生成个性化提醒消息
5. **UserPreferenceManager**: 用户偏好工具，学习和优化用户偏好
6. **ReminderScheduler**: 定时调度器，管理提醒的定时执行

## 工具详细设计

### 1. TimeManager

时间管理工具，提供时间格式验证、下次提醒时间计算等功能。

**主要功能**：
- 验证时间格式是否符合HH:MM格式
- 计算下一次提醒时间
- 计算距离下次提醒的时间间隔
- 将时间间隔格式化为友好的字符串

### 2. NotificationManager

通知工具，支持多种提醒方式，包括文本、声音和弹窗。

**主要功能**：
- 发送不同类型的通知
- 支持通知优先级设置
- 提供备用通知方式（失败时自动切换）
- 返回通知发送结果

### 3. DataManager

数据存储工具，负责管理用户配置、提醒历史和消息模板。

**主要功能**：
- 初始化和管理数据文件
- 安全地保存和加载JSON数据
- 提供用户配置的读写接口
- 管理提醒历史记录
- 处理消息模板数据
- 支持用户数据清除（隐私保护）

### 4. MessageTemplateManager

消息模板工具，用于生成个性化的提醒消息。

**主要功能**：
- 获取和管理消息模板
- 生成个性化提醒消息
- 记录模板使用情况和有效性
- 识别最有效的消息模板

### 5. UserPreferenceManager

用户偏好工具，分析用户行为并优化提醒策略。

**主要功能**：
- 分析用户行为模式
- 生成优化建议
- 应用推荐的优化
- 自动优化用户体验

### 6. ReminderScheduler

定时调度器，负责在指定时间触发提醒。

**主要功能**：
- 根据用户配置安排提醒
- 发送提醒通知
- 处理重复提醒逻辑
- 记录用户响应
- 管理定时器生命周期

## 工具代码实现

```python
# sleep_reminder_tools.py
"""
睡眠提醒Agent工具集
包含时间管理、通知、数据存储、消息模板和用户偏好工具
"""

import json
import os
import time
from datetime import datetime, timedelta
import re
import threading
import logging
from pathlib import Path
from typing import Dict, List, Optional, Union, Tuple, Any

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("sleep_reminder_tools")

# 工具1: 时间管理工具
class TimeManager:
    """时间管理工具，用于设置、验证和计算睡眠提醒时间"""
    
    @staticmethod
    def validate_time_format(time_str: str) -> bool:
        """验证时间格式是否符合HH:MM格式"""
        pattern = r'^([01]\d|2[0-3]):([0-5]\d)$'
        return bool(re.match(pattern, time_str))
    
    @staticmethod
    def get_next_reminder_time(sleep_time: str) -> datetime:
        """
        计算下一次提醒时间
        
        Args:
            sleep_time: 格式为"HH:MM"的睡眠时间
            
        Returns:
            下一次提醒的datetime对象
        """
        if not TimeManager.validate_time_format(sleep_time):
            raise ValueError(f"时间格式错误: {sleep_time}，应为HH:MM格式")
        
        now = datetime.now()
        hour, minute = map(int, sleep_time.split(':'))
        
        # 创建今天的提醒时间
        reminder_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
        
        # 如果今天的提醒时间已过，则设置为明天
        if reminder_time <= now:
            reminder_time += timedelta(days=1)
            
        return reminder_time
    
    @staticmethod
    def get_time_until_reminder(sleep_time: str) -> timedelta:
        """计算距离下次提醒的时间间隔"""
        next_reminder = TimeManager.get_next_reminder_time(sleep_time)
        return next_reminder - datetime.now()
    
    @staticmethod
    def format_time_delta(delta: timedelta) -> str:
        """将时间间隔格式化为友好的字符串"""
        total_seconds = int(delta.total_seconds())
        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        if hours > 0:
            return f"{hours}小时{minutes}分钟"
        elif minutes > 0:
            return f"{minutes}分钟{seconds}秒"
        else:
            return f"{seconds}秒"


# 工具2: 通知工具
class NotificationManager:
    """通知工具，支持多种提醒方式（文本、声音、弹窗）"""
    
    NOTIFICATION_METHODS = ["text", "sound", "popup"]
    
    @staticmethod
    def send_notification(
        message: str, 
        methods: List[str] = ["text"], 
        priority: str = "normal"
    ) -> Dict[str, bool]:
        """
        发送通知
        
        Args:
            message: 通知消息内容
            methods: 通知方式列表，可包含"text", "sound", "popup"
            priority: 通知优先级，可为"low", "normal", "high"
            
        Returns:
            各通知方式的发送结果
        """
        results = {}
        
        # 验证通知方式
        for method in methods:
            if method not in NotificationManager.NOTIFICATION_METHODS:
                logger.warning(f"不支持的通知方式: {method}")
                results[method] = False
                continue
            
            # 实际应用中这里会调用系统API发送不同类型的通知
            # 这里仅作为模拟实现
            try:
                logger.info(f"发送{priority}优先级{method}通知: {message}")
                # 模拟通知发送
                time.sleep(0.1)  
                results[method] = True
            except Exception as e:
                logger.error(f"发送{method}通知失败: {str(e)}")
                results[method] = False
                
        return results
    
    @staticmethod
    def send_with_fallback(message: str, methods: List[str], fallbacks: List[str] = None) -> Dict[str, Any]:
        """
        发送通知，如果主要方式失败则使用备用方式
        
        Args:
            message: 通知消息
            methods: 主要通知方式
            fallbacks: 备用通知方式
            
        Returns:
            通知结果信息
        """
        if fallbacks is None:
            # 默认备用方式为文本
            fallbacks = ["text"]
            
        results = NotificationManager.send_notification(message, methods)
        
        # 检查是否有失败的通知方式
        failed_methods = [m for m, success in results.items() if not success]
        if failed_methods and fallbacks:
            logger.info(f"主要通知方式 {failed_methods} 失败，尝试备用方式 {fallbacks}")
            fallback_results = NotificationManager.send_notification(message, fallbacks)
            
            # 更新结果
            results.update({
                "fallback_used": True,
                "fallback_results": fallback_results
            })
        else:
            results.update({
                "fallback_used": False
            })
            
        return results


# 工具3: 数据存储工具
class DataManager:
    """数据存储工具，管理用户配置和历史记录"""
    
    def __init__(self, storage_dir: str = "data"):
        """
        初始化数据管理器
        
        Args:
            storage_dir: 数据存储目录
        """
        self.storage_dir = storage_dir
        self.config_file = os.path.join(storage_dir, "user_config.json")
        self.history_file = os.path.join(storage_dir, "reminder_history.json")
        self.templates_file = os.path.join(storage_dir, "message_templates.json")
        
        # 确保存储目录存在
        os.makedirs(storage_dir, exist_ok=True)
        
        # 初始化文件
        self._init_files()
        
    def _init_files(self):
        """初始化数据文件"""
        # 用户配置
        if not os.path.exists(self.config_file):
            default_config = {
                "user_id": "default_user",
                "sleep_time": "22:00",
                "reminder_methods": ["text"],
                "repeat_rules": {
                    "enabled": False,
                    "interval_minutes": 10,
                    "max_repeats": 3
                },
                "message_template": "default",
                "preferences": {
                    "message_style": "friendly",
                    "notification_priority": "normal"
                },
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat()
            }
            self._save_json(self.config_file, default_config)
        
        # 提醒历史
        if not os.path.exists(self.history_file):
            self._save_json(self.history_file, [])
            
        # 消息模板
        if not os.path.exists(self.templates_file):
            default_templates = [
                {
                    "template_id": "default",
                    "template_name": "默认提醒",
                    "content_pattern": "现在是{time}，该准备睡觉了！保持良好的作息习惯有助于健康。",
                    "variables": ["time"],
                    "style_type": "friendly",
                    "usage_count": 0,
                    "effectiveness_score": 0.5
                },
                {
                    "template_id": "gentle",
                    "template_name": "温和提醒",
                    "content_pattern": "温馨提示：距离您设定的睡眠时间还有{time_left}，建议开始放松准备休息。",
                    "variables": ["time_left"],
                    "style_type": "gentle",
                    "usage_count": 0,
                    "effectiveness_score": 0.5
                },
                {
                    "template_id": "direct",
                    "template_name": "直接提醒",
                    "content_pattern": "睡眠提醒：请在{time_left}内完成当前活动并准备就寝。",
                    "variables": ["time_left"],
                    "style_type": "direct",
                    "usage_count": 0,
                    "effectiveness_score": 0.5
                }
            ]
            self._save_json(self.templates_file, default_templates)
    
    def _save_json(self, file_path: str, data: Any):
        """安全地保存JSON数据"""
        try:
            # 使用临时文件避免写入中断导致数据损坏
            temp_file = f"{file_path}.tmp"
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            # 替换原文件
            if os.path.exists(file_path):
                os.replace(temp_file, file_path)
            else:
                os.rename(temp_file, file_path)
                
            return True
        except Exception as e:
            logger.error(f"保存数据失败: {str(e)}")
            return False
    
    def _load_json(self, file_path: str) -> Any:
        """安全地加载JSON数据"""
        try:
            if not os.path.exists(file_path):
                return None
                
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"加载数据失败: {str(e)}")
            return None
    
    def get_user_config(self) -> Dict:
        """获取用户配置"""
        return self._load_json(self.config_file) or {}
    
    def update_user_config(self, config_updates: Dict) -> bool:
        """更新用户配置"""
        current_config = self.get_user_config()
        current_config.update(config_updates)
        current_config["updated_at"] = datetime.now().isoformat()
        return self._save_json(self.config_file, current_config)
    
    def get_reminder_history(self) -> List[Dict]:
        """获取提醒历史记录"""
        return self._load_json(self.history_file) or []
    
    def add_reminder_history(self, reminder_data: Dict) -> bool:
        """添加提醒历史记录"""
        history = self.get_reminder_history()
        reminder_data["id"] = f"rem_{int(time.time())}"
        history.append(reminder_data)
        return self._save_json(self.history_file, history)
    
    def get_message_templates(self) -> List[Dict]:
        """获取消息模板"""
        return self._load_json(self.templates_file) or []
    
    def get_template_by_id(self, template_id: str) -> Optional[Dict]:
        """根据ID获取特定模板"""
        templates = self.get_message_templates()
        for template in templates:
            if template["template_id"] == template_id:
                return template
        return None
    
    def update_template_usage(self, template_id: str, was_effective: bool = True) -> bool:
        """更新模板使用情况和有效性评分"""
        templates = self.get_message_templates()
        updated = False
        
        for template in templates:
            if template["template_id"] == template_id:
                template["usage_count"] += 1
                
                # 更新有效性评分（简单加权平均）
                current_score = template["effectiveness_score"]
                current_count = template["usage_count"]
                
                if was_effective:
                    new_score = (current_score * (current_count - 1) + 1) / current_count
                else:
                    new_score = (current_score * (current_count - 1) + 0) / current_count
                    
                template["effectiveness_score"] = round(new_score, 2)
                updated = True
                break
                
        if updated:
            return self._save_json(self.templates_file, templates)
        return False
    
    def clear_user_data(self) -> bool:
        """清除所有用户数据（隐私保护）"""
        try:
            # 重置配置
            default_config = {
                "user_id": "default_user",
                "sleep_time": "22:00",
                "reminder_methods": ["text"],
                "repeat_rules": {
                    "enabled": False,
                    "interval_minutes": 10,
                    "max_repeats": 3
                },
                "message_template": "default",
                "preferences": {
                    "message_style": "friendly",
                    "notification_priority": "normal"
                },
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat()
            }
            self._save_json(self.config_file, default_config)
            
            # 清空历史
            self._save_json(self.history_file, [])
            
            return True
        except Exception as e:
            logger.error(f"清除用户数据失败: {str(e)}")
            return False


# 工具4: 消息模板工具
class MessageTemplateManager:
    """消息模板工具，生成个性化提醒消息"""
    
    def __init__(self, data_manager: DataManager):
        """
        初始化消息模板管理器
        
        Args:
            data_manager: 数据管理器实例
        """
        self.data_manager = data_manager
    
    def get_template(self, template_id: str = None) -> Dict:
        """
        获取指定的消息模板
        
        Args:
            template_id: 模板ID，如果为None则使用用户配置中的默认模板
            
        Returns:
            消息模板
        """
        if template_id is None:
            # 使用用户配置中的默认模板
            user_config = self.data_manager.get_user_config()
            template_id = user_config.get("message_template", "default")
            
        template = self.data_manager.get_template_by_id(template_id)
        
        # 如果找不到指定模板，返回默认模板
        if not template:
            logger.warning(f"找不到模板 {template_id}，使用默认模板")
            template = self.data_manager.get_template_by_id("default")
            
        return template
    
    def generate_message(self, template_id: str = None, variables: Dict = None) -> str:
        """
        生成个性化提醒消息
        
        Args:
            template_id: 模板ID
            variables: 模板变量值
            
        Returns:
            生成的消息内容
        """
        template = self.get_template(template_id)
        
        if not template:
            return "该准备睡觉了！"
            
        content_pattern = template["content_pattern"]
        required_vars = template["variables"]
        
        # 如果没有提供变量，使用默认值
        if not variables:
            variables = {}
            
        # 检查是否提供了所有必要变量，如果没有则使用占位符
        for var in required_vars:
            if var not in variables:
                if var == "time":
                    variables[var] = datetime.now().strftime("%H:%M")
                elif var == "time_left":
                    variables[var] = "不久"
                else:
                    variables[var] = f"[{var}]"
        
        # 填充模板
        message = content_pattern
        for var, value in variables.items():
            message = message.replace(f"{{{var}}}", str(value))
            
        return message
    
    def record_template_usage(self, template_id: str, was_effective: bool = True) -> bool:
        """记录模板使用情况，更新有效性评分"""
        return self.data_manager.update_template_usage(template_id, was_effective)
    
    def get_most_effective_template(self) -> Dict:
        """获取最有效的消息模板"""
        templates = self.data_manager.get_message_templates()
        
        # 按有效性评分排序
        sorted_templates = sorted(
            templates, 
            key=lambda t: t["effectiveness_score"], 
            reverse=True
        )
        
        if sorted_templates:
            return sorted_templates[0]
        else:
            return None


# 工具5: 用户偏好工具
class UserPreferenceManager:
    """用户偏好工具，学习和优化用户偏好"""
    
    def __init__(self, data_manager: DataManager):
        """
        初始化用户偏好管理器
        
        Args:
            data_manager: 数据管理器实例
        """
        self.data_manager = data_manager
    
    def analyze_user_behavior(self) -> Dict:
        """
        分析用户行为模式
        
        Returns:
            分析结果
        """
        history = self.data_manager.get_reminder_history()
        
        if not history:
            return {
                "patterns_found": False,
                "recommendations": []
            }
            
        # 计算响应率
        total_reminders = len(history)
        responded_reminders = sum(1 for item in history if item.get("user_response"))
        response_rate = responded_reminders / total_reminders if total_reminders > 0 else 0
        
        # 分析响应时间
        response_times = []
        for item in history:
            if item.get("user_response") and item.get("response_time") and item.get("actual_sent_time"):
                sent_time = datetime.fromisoformat(item["actual_sent_time"])
                response_time = datetime.fromisoformat(item["response_time"])
                response_times.append((response_time - sent_time).total_seconds())
                
        avg_response_time = sum(response_times) / len(response_times) if response_times else None
        
        # 分析最有效的提醒方式
        method_success = {}
        for item in history:
            method = item.get("method_used")
            success = item.get("success", False)
            
            if method:
                if method not in method_success:
                    method_success[method] = {"success": 0, "total": 0}
                    
                method_success[method]["total"] += 1
                if success:
                    method_success[method]["success"] += 1
        
        # 计算各方式的成功率
        method_success_rate = {}
        for method, stats in method_success.items():
            if stats["total"] > 0:
                method_success_rate[method] = stats["success"] / stats["total"]
            else:
                method_success_rate[method] = 0
                
        # 找出最有效的方式
        best_method = max(method_success_rate.items(), key=lambda x: x[1])[0] if method_success_rate else None
        
        # 生成建议
        recommendations = []
        
        if response_rate < 0.5 and total_reminders >= 5:
            recommendations.append({
                "type": "response_rate",
                "message": "用户对提醒的响应率较低，建议调整提醒方式或内容",
                "suggested_action": "try_different_method"
            })
            
        if best_method and best_method != self.data_manager.get_user_config().get("reminder_methods", ["text"])[0]:
            recommendations.append({
                "type": "method_preference",
                "message": f"用户对{best_method}方式的提醒响应最好",
                "suggested_action": "change_primary_method",
                "suggested_value": best_method
            })
            
        # 分析用户忽略提醒的时间模式
        ignored_times = []
        for item in history:
            if not item.get("user_response") and item.get("actual_sent_time"):
                sent_time = datetime.fromisoformat(item["actual_sent_time"])
                ignored_times.append(sent_time.hour)
                
        # 如果有明显的被忽略时间段
        if ignored_times:
            from collections import Counter
            time_counter = Counter(ignored_times)
            most_ignored_hour, count = time_counter.most_common(1)[0]
            
            if count >= 3 and count / len(ignored_times) >= 0.5:
                # 建议调整提醒时间
                recommendations.append({
                    "type": "timing_adjustment",
                    "message": f"用户经常在{most_ignored_hour}点忽略提醒",
                    "suggested_action": "adjust_reminder_time",
                    "suggested_value": f"{(most_ignored_hour - 1) % 24:02d}:00" 
                })
        
        return {
            "patterns_found": len(recommendations) > 0,
            "response_rate": response_rate,
            "avg_response_time": avg_response_time,
            "best_method": best_method,
            "recommendations": recommendations
        }
    
    def apply_recommendation(self, recommendation: Dict) -> bool:
        """
        应用推荐的优化
        
        Args:
            recommendation: 推荐配置
            
        Returns:
            是否成功应用
        """
        action = recommendation.get("suggested_action")
        value = recommendation.get("suggested_value")
        
        if not action or not value:
            return False
            
        user_config = self.data_manager.get_user_config()
        
        if action == "change_primary_method":
            user_config["reminder_methods"] = [value] + [
                m for m in user_config.get("reminder_methods", []) 
                if m != value
            ]
            return self.data_manager.update_user_config(user_config)
            
        elif action == "adjust_reminder_time":
            if TimeManager.validate_time_format(value):
                user_config["sleep_time"] = value
                return self.data_manager.update_user_config(user_config)
                
        elif action == "try_different_method":
            # 尝试不同的提醒方式
            current_methods = user_config.get("reminder_methods", ["text"])
            all_methods = NotificationManager.NOTIFICATION_METHODS
            
            # 找出未使用的方法
            unused_methods = [m for m in all_methods if m not in current_methods]
            
            if unused_methods:
                # 添加一个未使用的方法
                user_config["reminder_methods"] = current_methods + [unused_methods[0]]
                return self.data_manager.update_user_config(user_config)
                
        return False
    
    def optimize_user_experience(self) -> Dict:
        """
        自动优化用户体验
        
        Returns:
            优化结果
        """
        analysis = self.analyze_user_behavior()
        
        if not analysis["patterns_found"]:
            return {
                "optimized": False,
                "message": "没有发现可优化的模式"
            }
            
        # 应用推荐
        applied = []
        for recommendation in analysis["recommendations"]:
            success = self.apply_recommendation(recommendation)
            if success:
                applied.append(recommendation["type"])
                
        return {
            "optimized": len(applied) > 0,
            "applied_optimizations": applied,
            "message": f"已应用{len(applied)}项优化" if applied else "无法应用优化"
        }


# 工具6: 定时调度器
class ReminderScheduler:
    """定时调度器，管理提醒的定时执行"""
    
    def __init__(
        self, 
        data_manager: DataManager, 
        message_manager: MessageTemplateManager,
        notification_manager: NotificationManager
    ):
        """
        初始化定时调度器
        
        Args:
            data_manager: 数据管理器实例
            message_manager: 消息模板管理器实例
            notification_manager: 通知管理器实例
        """
        self.data_manager = data_manager
        self.message_manager = message_manager
        self.notification_manager = notification_manager
        self.timer = None
        self.repeat_timers = {}
    
    def schedule_reminder(self):
        """根据用户配置安排下一次提醒"""
        # 取消现有定时器
        self._cancel_timers()
        
        # 获取用户配置
        config = self.data_manager.get_user_config()
        sleep_time = config.get("sleep_time", "22:00")
        
        try:
            # 计算下次提醒时间
            next_reminder = TimeManager.get_next_reminder_time(sleep_time)
            time_until = (next_reminder - datetime.now()).total_seconds()
            
            if time_until <= 0:
                logger.warning("计算的提醒时间已过，将立即发送提醒")
                time_until = 1  # 立即发送
                
            # 设置定时器
            self.timer = threading.Timer(time_until, self._send_reminder)
            self.timer.daemon = True  # 设为守护线程，不阻止程序退出
            self.timer.start()
            
            logger.info(f"已安排下次提醒: {next_reminder.isoformat()}, {TimeManager.format_time_delta(timedelta(seconds=time_until))}后")
            
            return {
                "scheduled": True,
                "next_reminder": next_reminder.isoformat(),
                "time_until": TimeManager.format_time_delta(timedelta(seconds=time_until))
            }
            
        except Exception as e:
            logger.error(f"安排提醒失败: {str(e)}")
            return {
                "scheduled": False,
                "error": str(e)
            }
    
    def _send_reminder(self):
        """发送提醒"""
        try:
            # 获取用户配置
            config = self.data_manager.get_user_config()
            methods = config.get("reminder_methods", ["text"])
            template_id = config.get("message_template", "default")
            
            # 生成提醒消息
            now = datetime.now()
            variables = {
                "time": now.strftime("%H:%M")
            }
            message = self.message_manager.generate_message(template_id, variables)
            
            # 发送通知
            results = self.notification_manager.send_with_fallback(message, methods)
            
            # 记录历史
            history_entry = {
                "user_id": config.get("user_id", "default_user"),
                "scheduled_time": now.isoformat(),
                "actual_sent_time": now.isoformat(),
                "message_content": message,
                "method_used": methods[0] if methods else "text",
                "user_response": None,
                "response_time": None,
                "repeat_count": 0,
                "success": any(results[m] for m in methods if m in results)
            }
            self.data_manager.add_reminder_history(history_entry)
            
            # 处理重复提醒
            repeat_rules = config.get("repeat_rules", {})
            if repeat_rules.get("enabled", False):
                self._schedule_repeat_reminder(history_entry["id"], repeat_rules)
                
            # 安排下一次提醒
            self.schedule_reminder()
            
        except Exception as e:
            logger.error(f"发送提醒失败: {str(e)}")
            # 尝试重新安排
            self.schedule_reminder()
    
    def _schedule_repeat_reminder(self, reminder_id: str, repeat_rules: Dict):
        """安排重复提醒"""
        interval_minutes = repeat_rules.get("interval_minutes", 10)
        max_repeats = repeat_rules.get("max_repeats", 3)
        
        if interval_minutes <= 0 or max_repeats <= 0:
            return
            
        # 创建重复提醒计数器
        if reminder_id not in self.repeat_timers:
            self.repeat_timers[reminder_id] = {
                "count": 0,
                "timers": []
            }
            
        repeat_data = self.repeat_timers[reminder_id]
        
        # 如果还未达到最大重复次数，安排下一次重复
        if repeat_data["count"] < max_repeats:
            # 增加计数
            repeat_data["count"] += 1
            
            # 创建定时器
            timer = threading.Timer(
                interval_minutes * 60, 
                self._send_repeat_reminder,
                args=[reminder_id, repeat_data["count"]]
            )
            timer.daemon = True
            timer.start()
            
            # 保存定时器引用
            repeat_data["timers"].append(timer)
    
    def _send_repeat_reminder(self, original_id: str, repeat_count: int):
        """发送重复提醒"""
        try:
            # 获取用户配置
            config = self.data_manager.get_user_config()
            methods = config.get("reminder_methods", ["text"])
            template_id = config.get("message_template", "default")
            
            # 生成提醒消息（添加重复标记）
            now = datetime.now()
            variables = {
                "time": now.strftime("%H:%M")
            }
            base_message = self.message_manager.generate_message(template_id, variables)
            message = f"[重复提醒 {repeat_count}] {base_message}"
            
            # 发送通知
            results = self.notification_manager.send_with_fallback(message, methods)
            
            # 记录历史
            history_entry = {
                "user_id": config.get("user_id", "default_user"),
                "scheduled_time": now.isoformat(),
                "actual_sent_time": now.isoformat(),
                "message_content": message,
                "method_used": methods[0] if methods else "text",
                "user_response": None,
                "response_time": None,
                "repeat_count": repeat_count,
                "success": any(results[m] for m in methods if m in results),
                "original_reminder_id": original_id
            }
            self.data_manager.add_reminder_history(history_entry)
            
        except Exception as e:
            logger.error(f"发送重复提醒失败: {str(e)}")
    
    def record_user_response(self, reminder_id: str, response: str = "acknowledged"):
        """记录用户对提醒的响应"""
        history = self.data_manager.get_reminder_history()
        updated = False
        
        for item in history:
            if item.get("id") == reminder_id:
                item["user_response"] = response
                item["response_time"] = datetime.now().isoformat()
                updated = True
                
                # 取消该提醒的所有重复
                if reminder_id in self.repeat_timers:
                    for timer in self.repeat_timers[reminder_id]["timers"]:
                        if timer.is_alive():
                            timer.cancel()
                    del self.repeat_timers[reminder_id]
                
                break
                
        if updated:
            return self.data_manager.update_user_config(history)
        return False
    
    def _cancel_timers(self):
        """取消所有定时器"""
        # 取消主定时器
        if self.timer and self.timer.is_alive():
            self.timer.cancel()
            self.timer = None
            
        # 取消所有重复定时器
        for reminder_id, repeat_data in self.repeat_timers.items():
            for timer in repeat_data["timers"]:
                if timer.is_alive():
                    timer.cancel()
                    
        self.repeat_timers = {}
```

## 工具依赖关系

工具之间的依赖关系如下：

1. **ReminderScheduler** 依赖于：
   - DataManager
   - MessageTemplateManager
   - NotificationManager

2. **MessageTemplateManager** 依赖于：
   - DataManager

3. **UserPreferenceManager** 依赖于：
   - DataManager

4. **TimeManager** 和 **NotificationManager** 无依赖，可独立使用

## 工具使用示例

```python
# 初始化数据管理器
data_manager = DataManager(storage_dir="user_data")

# 初始化消息模板管理器
message_manager = MessageTemplateManager(data_manager)

# 初始化用户偏好管理器
preference_manager = UserPreferenceManager(data_manager)

# 设置用户睡眠时间
data_manager.update_user_config({
    "sleep_time": "23:00",
    "reminder_methods": ["text", "sound"],
    "repeat_rules": {
        "enabled": True,
        "interval_minutes": 15,
        "max_repeats": 2
    }
})

# 初始化定时调度器
scheduler = ReminderScheduler(
    data_manager,
    message_manager,
    NotificationManager
)

# 安排提醒
result = scheduler.schedule_reminder()
print(f"下次提醒将在 {result['time_until']} 后发送")

# 生成测试消息
message = message_manager.generate_message(
    template_id="gentle",
    variables={"time_left": "30分钟"}
)
print(f"提醒消息: {message}")

# 分析用户行为
after_some_usage = preference_manager.analyze_user_behavior()
if after_some_usage["patterns_found"]:
    print("发现用户行为模式，应用优化...")
    preference_manager.optimize_user_experience()
```

## 安全和隐私考虑

1. 用户数据存储在本地，不会上传到云端
2. 提供完整的数据删除功能，支持用户清除所有历史记录
3. 不收集用户敏感个人信息
4. 使用安全的JSON文件写入机制，避免数据损坏

## 性能考虑

1. 使用轻量级线程定时器，减少系统资源消耗
2. 采用异步处理通知发送，避免阻塞主线程
3. 定期清理历史数据，避免存储空间无限增长
4. 优化消息生成算法，减少CPU使用率

## 扩展性考虑

1. 模块化设计，各组件职责明确，易于扩展
2. 支持添加新的通知方式
3. 支持自定义消息模板
4. 预留用户偏好学习机制的扩展接口